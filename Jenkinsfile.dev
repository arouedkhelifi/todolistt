pipeline {
    agent any

    /*
     * Jenkinsfile (Windows agent) — Pipeline pour la branche `dev`
     *
     * Pré-requis :
     * - Exécuter ce pipeline dans un job Multibranch Pipeline (checkout scm disponible).
     * - Agent Windows avec Docker Desktop et docker-compose installés et accessibles
     *   par l'utilisateur qui exécute l'agent Jenkins (ou configurer DOCKER_HOST).
     * - Si le repo est privé, configurer des credentials dans Branch Source.
     *
     * But :
     * - Checkout du code (branche dev)
     * - Vérifications d'environnement (docker, docker-compose)
     * - Build via docker-compose
     * - Lancement des services
     * - Tests de fumée (smoke tests)
     * - Archivage des artefacts
     * - Nettoyage
     *
     * Remarques de sécurité :
     * - N'exposez pas le daemon Docker sans TLS en production. Préférez un agent
     *   JNLP lancé par l'utilisateur qui a Docker Desktop pour un accès fiable au pipe.
     */

    options {
        timeout(time: 1, unit: 'HOURS')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    environment {
        PROJECT_NAME  = "todolistt"
        ARTIFACTS_DIR = "${WORKSPACE}\\artifacts"
        IMAGE_TAG     = "${BUILD_NUMBER}-dev"
        // BUILD_TIMESTAMP est calculé au runtime dans la stage 'Setup'
    }

    stages {
        /**************************************************************************
         * 1) Checkout
         * - Utiliser checkout scm (Multibranch Pipeline).
         * - Affiche seulement la branche et les commits récents (utile au debug).
         **************************************************************************/
        stage('Checkout') {
            steps {
                checkout scm
                // Affiche le nom de branche et les 10 derniers commits (court)
                bat 'git rev-parse --abbrev-ref HEAD && git log --oneline -n 10'
            }
        }

        /**************************************************************************
         * 2) Setup
         * - Calcul du BUILD_TIMESTAMP (Groovy) pour l'utiliser dans les bat.
         * - Création du dossier artifacts et vérification minimale de docker.
         **************************************************************************/
        stage('Setup') {
            steps {
                script {
                    // BUILD_TIMESTAMP calculé en Groovy pour consistance Windows bat
                    env.BUILD_TIMESTAMP = new Date().format('yyyyMMdd_HHmmss')
                }
                bat """
                    if not exist "%ARTIFACTS_DIR%" mkdir "%ARTIFACTS_DIR%"

                    rem -> Vérifier la disponibilité de Docker et docker-compose
                    docker version > "%ARTIFACTS_DIR%\\docker_version_%BUILD_TIMESTAMP%.txt" 2>&1 || echo docker-not-available > "%ARTIFACTS_DIR%\\docker_version_%BUILD_TIMESTAMP%.txt"
                    docker-compose version > "%ARTIFACTS_DIR%\\docker_compose_version_%BUILD_TIMESTAMP%.txt" 2>&1 || echo docker-compose-not-available > "%ARTIFACTS_DIR%\\docker_compose_version_%BUILD_TIMESTAMP%.txt"

                    rem -> Existence de scripts utiles
                    if exist scripts\\smoke-tests.sh (
                      echo smoke-tests.sh:found > "%ARTIFACTS_DIR%\\script_presence_%BUILD_TIMESTAMP%.txt"
                    ) else (
                      echo smoke-tests.sh:not-found > "%ARTIFACTS_DIR%\\script_presence_%BUILD_TIMESTAMP%.txt"
                    )
                """
            }
        }

        /**************************************************************************
         * 3) Build
         * - Construction via docker-compose (logs capturés).
         * - Échec explicite en cas d'erreur de build.
         **************************************************************************/
        stage('Build') {
            steps {
                bat """
                    docker-compose build > "%ARTIFACTS_DIR%\\docker_build_%BUILD_TIMESTAMP%.log" 2>&1
                    if %ERRORLEVEL% NEQ 0 (
                        echo Docker Compose build failed - see log
                        type "%ARTIFACTS_DIR%\\docker_build_%BUILD_TIMESTAMP%.log"
                        exit /b 1
                    )
                """
            }
        }

        /**************************************************************************
         * 4) Run Docker Stack
         * - Redéployer en mode détaché.
         * - Attendre l'initialisation minimale.
         **************************************************************************/
        stage('Run Docker Stack') {
            steps {
                bat """
                    docker-compose down -v > "%ARTIFACTS_DIR%\\docker_down_%BUILD_TIMESTAMP%.log" 2>&1 || echo no-stack > "%ARTIFACTS_DIR%\\docker_down_%BUILD_TIMESTAMP%.log"
                    docker rm -f %PROJECT_NAME%-mongodb %PROJECT_NAME%-backend %PROJECT_NAME%-frontend > "%ARTIFACTS_DIR%\\docker_rm_%BUILD_TIMESTAMP%.log" 2>&1 || echo no-containers >> "%ARTIFACTS_DIR%\\docker_rm_%BUILD_TIMESTAMP%.log"
                    docker container prune -f > "%ARTIFACTS_DIR%\\docker_container_prune_%BUILD_TIMESTAMP%.log" 2>&1 || echo prune-skipped >> "%ARTIFACTS_DIR%\\docker_container_prune_%BUILD_TIMESTAMP%.log"

                    docker-compose up -d > "%ARTIFACTS_DIR%\\docker_up_%BUILD_TIMESTAMP%.log" 2>&1
                    rem Attente courte pour l'initialisation
                    ping -n 21 127.0.0.1 >nul
                    docker-compose ps > "%ARTIFACTS_DIR%\\container_status_%BUILD_TIMESTAMP%.log" 2>&1 || echo ps-failed > "%ARTIFACTS_DIR%\\container_status_%BUILD_TIMESTAMP%.log"
                """
            }
        }

        /**************************************************************************
         * 5) Smoke Tests
         * - Vérifications HTTP et état des conteneurs.
         * - Utilise curl si disponible, PowerShell sinon.
         **************************************************************************/
        stage('Smoke Test') {
            steps {
                bat """
                    @echo off
                    setlocal enabledelayedexpansion
                    set PASSED=0
                    set FAILED=0

                    rem Backend health
                    where curl >nul 2>&1
                    if %ERRORLEVEL% EQU 0 (
                      curl -s -f http://localhost:5000/health >nul 2>&1
                    ) else (
                      powershell -Command "try { Invoke-WebRequest -Uri 'http://localhost:5000/health' -UseBasicParsing -TimeoutSec 5 | Out-Null; exit 0 } catch { exit 1 }"
                    )
                    if %ERRORLEVEL% EQU 0 ( set /a PASSED+=1 ) else (
                        rem fallback root
                        where curl >nul 2>&1
                        if %ERRORLEVEL% EQU 0 ( curl -s -f http://localhost:5000 >nul 2>&1 ) else ( powershell -Command "try { Invoke-WebRequest -Uri 'http://localhost:5000' -UseBasicParsing -TimeoutSec 5 | Out-Null; exit 0 } catch { exit 1 }" )
                        if %ERRORLEVEL% EQU 0 ( set /a PASSED+=1 ) else ( set /a FAILED+=1 )
                    )

                    rem Frontend
                    where curl >nul 2>&1
                    if %ERRORLEVEL% EQU 0 ( curl -s -f http://localhost:3000 >nul 2>&1 ) else ( powershell -Command "try { Invoke-WebRequest -Uri 'http://localhost:3000' -UseBasicParsing -TimeoutSec 5 | Out-Null; exit 0 } catch { exit 1 }" )
                    if %ERRORLEVEL% EQU 0 ( set /a PASSED+=1 ) else ( set /a FAILED+=1 )

                    rem Container checks
                    docker ps --filter "name=%PROJECT_NAME%-mongodb" --format "{{.State}}" | findstr "running" >nul 2>&1
                    if %ERRORLEVEL% EQU 0 ( set /a PASSED+=1 ) else ( set /a FAILED+=1 )

                    docker ps --filter "name=%PROJECT_NAME%-backend" --format "{{.State}}" | findstr "running" >nul 2>&1
                    if %ERRORLEVEL% EQU 0 ( set /a PASSED+=1 ) else ( set /a FAILED+=1 )

                    docker ps --filter "name=%PROJECT_NAME%-frontend" --format "{{.State}}" | findstr "running" >nul 2>&1
                    if %ERRORLEVEL% EQU 0 ( set /a PASSED+=1 ) else ( set /a FAILED+=1 )

                    docker network ls | findstr "%PROJECT_NAME%-network" >nul 2>&1
                    if %ERRORLEVEL% EQU 0 ( set /a PASSED+=1 ) else ( set /a FAILED+=1 )

                    rem Résumé minimal (journalisé dans console pour faciliter diagnostic)
                    echo Tests Passed: %PASSED%/6  Tests Failed: %FAILED%/6

                    if %FAILED% GTR 0 (
                        exit /b 1
                    ) else (
                        exit /b 0
                    )
                """
            }
        }

        /**************************************************************************
         * 6) Archive Artifacts
         * - Rassemble logs et état docker-compose puis archive dans Jenkins.
         **************************************************************************/
        stage('Archive Artifacts') {
            steps {
                bat """
                    echo Build Number: %BUILD_NUMBER% > "%ARTIFACTS_DIR%\\dev_pipeline_report_%BUILD_TIMESTAMP%.txt"
                    echo Build Timestamp: %BUILD_TIMESTAMP% >> "%ARTIFACTS_DIR%\\dev_pipeline_report_%BUILD_TIMESTAMP%.txt"
                    echo Branch: %BRANCH_NAME% >> "%ARTIFACTS_DIR%\\dev_pipeline_report_%BUILD_TIMESTAMP%.txt"
                    docker-compose ps >> "%ARTIFACTS_DIR%\\dev_pipeline_report_%BUILD_TIMESTAMP%.txt" 2>&1 || echo no-compose-status >> "%ARTIFACTS_DIR%\\dev_pipeline_report_%BUILD_TIMESTAMP%.txt"
                    docker-compose logs --no-color > "%ARTIFACTS_DIR%\\docker_logs_%BUILD_TIMESTAMP%.log" 2>&1 || echo no-logs > "%ARTIFACTS_DIR%\\docker_logs_%BUILD_TIMESTAMP%.log"
                    dir "%ARTIFACTS_DIR%" > "%ARTIFACTS_DIR%\\dir_listing_%BUILD_TIMESTAMP%.txt"
                """
                archiveArtifacts artifacts: 'artifacts/**', fingerprint: true, allowEmptyArchive: true
            }
        }

        /**************************************************************************
         * 7) Cleanup
         * - Tentative d'arrêt propre et nettoyage best-effort.
         **************************************************************************/
        stage('Cleanup') {
            steps {
                bat """
                    docker-compose down -v > "%ARTIFACTS_DIR%\\docker_down_after_%BUILD_TIMESTAMP%.log" 2>&1 || echo no-compose-to-stop >> "%ARTIFACTS_DIR%\\docker_down_after_%BUILD_TIMESTAMP%.log"
                    docker image prune -f --filter "dangling=true" > "%ARTIFACTS_DIR%\\image_prune_%BUILD_TIMESTAMP%.log" 2>&1 || echo no-dangling >> "%ARTIFACTS_DIR%\\image_prune_%BUILD_TIMESTAMP%.log"
                    docker volume prune -f > "%ARTIFACTS_DIR%\\volume_prune_%BUILD_TIMESTAMP%.log" 2>&1 || echo no-volumes >> "%ARTIFACTS_DIR%\\volume_prune_%BUILD_TIMESTAMP%.log"
                """
            }
        }
    }

    /**************************************************************************
     * Post actions
     * - En cas d'échec, tente de collecter des logs Docker si disponibles.
     **************************************************************************/
    post {
        always {
            echo "Pipeline finished - duration: ${currentBuild.durationString}"
        }
        success {
            echo "DEV PIPELINE PASSED"
        }
        failure {
            echo "DEV PIPELINE FAILED - attempting to collect docker logs (if accessible)"
            script {
                try {
                    bat 'docker version >nul 2>&1'
                    bat 'docker-compose logs --tail=50 > "%ARTIFACTS_DIR%\\post_failure_compose_logs_%BUILD_TIMESTAMP%.log" 2>&1 || echo no-logs'
                } catch (err) {
                    echo "Docker not accessible from agent; logs skipped"
                }
            }
        }
    }
}
